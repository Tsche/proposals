---
title: Library Support for Expansion Statements
document: D1789R1
date: 2025-03-17
audience:
  - Library Evolution Working Group
author:
  - name: Alisdair Meredith
    email: <ameredith1@bloomberg.net>
  - name: Matthias Wippich
    email: <mfwippich@gmail.com>
toc: true
---

# Revision History
## Revision 1
* Added section on use in structured bindings.
* Updated code examples to use the new expansion statement syntax from [@P1306R2].

## Revision 0
Original version of the paper for the 2019 pre-Cologne mailing.

# Introduction
Expansion statements will add compile-time iteration to C++26, but there are no compile-time sequences of integers that support this feature, for intuitive `for` loop indexing from the runtime world. There is an easy fix with a simple enhancement the library template `integer_sequence` to support the structured binding API.

# Stating the problem
Expansion statements are a new language feature originally intended for C++20, but despite feature approval by EWG they failed to land in time due to design and implementability concerns raised during the Core wording review.

Those concerns have now been addresses and [P1306R3 Expansion statements](https://wg21.link/p1306r3) was once again approved by EWG for adoption, now targeting C++26.

Expansion statements allow for iteration over a variety of compile-time sequences such as parameter packs and (`constexpr`) `span`s of reflections --- see [@P2996R9] for examples of reflection.

However, our very first attempt at an example of using an expansion statement came up short, due to the omission of a tiny piece of supporting library infrastructure.

## Implementing `std::tuple::swap`
It is relatively straightforward to implement `std::tuple::swap` using a fold expression over the comma operator, but also somewhat of a hack. This is the kind of code we would like to be able to write more cleanly using an expansion statement.

```cpp
template <class... TYPES>
constexpr
void tuple<TYPES...>::swap(tuple& other)
   noexcept((is_nothrow_swappable_v<TYPES> and ...))
{
   auto impl = [&, this]<size_t...INDEX>(index_sequence<INDEX...>) {
      ((void)swap(get<INDEX>(*this), get<INDEX>(other)), ...);
   };

   impl(index_sequence_for<TYPES...>{});
}
```

Note the internal use of a lambda expression, purely to get at the parameter pack to fold.  Also note that we must cast the call to `swap` to `void` in case users provide an ADL-discoverable `swap` function that returns a user defined type, that in turn provides an overload for the comma operator.  Finally, I took the liberty of not replicating the exception specification on the lambda expression, but is that relying too heavily on compilers to optimize away the (unneeded) catch-and-abort logic?

We can eliminate the fold expression and worrying about the crazy corner cases in ADL-`swap` like so:

```cpp
template <class... TYPES>
constexpr
void tuple<TYPES...>::swap(tuple& other)
   noexcept((is_nothrow_swappable_v<TYPES> and ...))
{
   auto impl = [&, this]<size_t...INDEX>(index_sequence<INDEX...>) {
      template for(constexpr size_t N : {INDEX...}) {
        swap(get<N>(*this), get<N>(other));
      }
   };

   impl(index_sequence_for<TYPES...>{});
}
```

However, there is no easy way to eliminate the lambda expression, as we cannot iterate over an `integer_sequence` using just the facilities provided in [@P1306R3].

## Propose Solution
The heart of the problem is that expansion statements are an excellent tool to iterate over a single sequence, but do not provide an index to support iterating over two sequences in parallel.

We propose that the simplest way to resolve the concerns is to add the missing pieces that would enable use of `integer_sequence` in a structured binding.
That is sufficient to support use in expansion statements, and is general enough to be a feature in its own right.  With such support, the `tuple::swap` example simplifies to:

```cpp
template <class... TYPES>
constexpr
void tuple<TYPES...>::swap(tuple& other)
   noexcept((is_nothrow_swappable_v<TYPES> and ...))
{
   template for(constexpr size_t N : index_sequence_for<TYPES...>{}) {
      swap(get<N>(*this), get<N>(other));
   }
}
```

### Make `integer_sequence` Support Structured Bindings
`integer_sequence` is missing three things in order to support use in structured bindings:

* A partial specialization for `tuple_size`
* A partial specialization for `tuple_elememt`
* Overloads of `get<INDEX>()`

The first two bullets are fairly straightforward to implement.  For the `get` function, we propose a single overload taking an `integer_sequence` by value, as it is an immutable empty type, and likewise returning its result by value.

## Use in structured bindings
Supporting decomposition of `integer_sequence`s interacts well with the proposed changes of [P1061R10 Structured Bindings can introduce a Pack](https://wg21.link/P1061R10) and [P2686R5 constexpr structured bindings](https://wg21.link/P2686R5).

In a lot of existing code the following pattern is used to introduce a sequence of integers as a pack of constants.

```cpp
[]<std::size_t... Idx>(std::index_sequence<Idx...>) {
  // ...
} (std::make_index_sequence<Count>());
```

Not only is this rather verbose, it introduces a new function scope. This can be avoided by introducing the pack of integers `Idx` through a structured binding instead.

```cpp
constexpr auto [...Idx] = std::make_index_sequence<Count>();
```

As [@P1306R3] mentions, introducing a new function scope can be problematic. For instance, reflections of function parameters ([@P3096R5]) can only be spliced within their corresponding function body. Expansion statements alleviate this issue, but are not usable whenever we want to fold over a pack of reflections or expand them into an argument list.

For instance, consider the following invalid example.
```cpp
void foo(int x, char c) {
   [:expand(parameters_of(^^foo)):]
   >> []<auto... Parameters>() {
      bar([:Parameters:]...); // oops
   }
}
```

By using the features introduced in [@P1061R10] and [@P2686R5] introducing a new function scope can be avoided as follows.

```cpp
void foo(int x, char c) {
   constexpr auto [...Idx] = std::make_index_sequence<parameters_of(^^foo).size()>();
   bar([:parameters_of(^^foo)[Idx]:]...);
}
```

## Sample Implementation

```cpp
template<class T, T... VALUES>
struct tuple_size<integer_sequence<T, VALUES...>>
   : integral_constant<size_t, sizeof...(VALUES)>
{ };

template<size_t I, class T, T... VALUES>
  requires I < sizeof...(VALUES)
struct tuple_element<I, integer_sequence<T, VALUES...>> {
   using type = T;
};

template<size_t I, class T, T... VALUES>
constexpr T get(integer_sequence<T, VALUES...>) noexcept {
   constexpr T index[]{VALUES...};
   return index[I];
}
```

# Proposed Wording
Change __$19.2.1 Header <utility> synopsis [utility.syn]__ of [@N4762]:

>The header <utility> contains some basic function and class templates that are used throughout the rest of the library.
>
>```diff
>#include <initializer_list> // see 16.10.1
>
>namespace std {
>
>   ...
>
>// 19.3, Compile-time integer sequences
>template<class T, T...>
>   struct integer_sequence;
>
>template<size_t... I>
>   using index_sequence = integer_sequence<size_t, I...>;
>
>template<class T, T N>
>   using make_integer_sequence = integer_sequence<T, see below >;
>
>template<size_t N>
>   using make_index_sequence = make_integer_sequence<size_t, N>;
>
>template<class... T>
>   using index_sequence_for = make_index_sequence<sizeof...(T)>;
>
>
>+ // forward declaration for structured binding support
>+ template<class T> struct tuple_size;
>+    template<size_t I, class T> struct tuple_element;
>
>+ // structured binding support for integer_sequence
>+ template<class T, T...> 
>+    struct tuple_size<integer_sequence<T, T...>>;
>+ template<size_t I, class T, T...>
>+    struct tuple_element<I, integer_sequence<T, T...>>;
>
>+ template<size_t I, class T, T...>
>+    constexpr T get(integer_sequence<T, T...>) noexcept;
>
>// 19.4, class template pair
>template<class T1, class T2>
>   struct pair;
>
>   ...
>
>// 19.4.4, tuple-like access to pair
>- template<class T> class tuple_size;
>- template<size_t I, class T> class tuple_element;
>
>template<class T1, class T2> struct tuple_size<pair<T1, T2>>;
>template<size_t I, class T1, class T2> struct tuple_element<I, pair<T1, T2>>;
>
>   ...
>
>}
>```

Add section __$19.3.4 Structured Binding Support [intseq.binding]__ to [@N4762]:

>::: add
>```cpp
>template<class T, T...>
>struct tuple_size<integer_sequence<T, T...>>: integral_constant<size_t, N> { };
>
>template<size_t I, class T, T...>
>struct tuple_element<I, integer_sequence<T, T...>>::type
>```
>:::
>
>* [1]{.pnum} [_Mandates:_ `I < N` is `true`.]{.add}
>* [2]{.pnum} [_Value:_ The type `T`.]{.add}
>
>:::add
>```cpp
>template<size_t I, class T, T...>
>constexpr T get(integer_sequence<T, T...>) noexcept;
>```
>:::
>
>* [3]{.pnum} [_Mandates:_ `I < N` is `true`.]{.add}
>* [4]{.pnum} [_Value:_ The `I`<sup>th</sup> member of the parameter pack `T...`.]{.add}


## Acknowledgements
Thanks to Vittorio Romeo and Daveed Vandevoorde for their insights into the contents of this paper.
