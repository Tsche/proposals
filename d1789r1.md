---
title:    Library Support for Expansion Statements
document: D1789R1
date:     2025-03-17
audience: Library Evolution
author:
 - name:  Alisdair Meredith
   email: <ameredith1@bloomberg.net>
 - name:  Jeremy Rifkin
   email: <jeremy@rifkin.dev>
 - name:  Matthias Wippich
   email: <mfwippich@gmail.com>
toc: true
toc-depth: 2
---

<!--
PRE-PRINT --- THIS DOCUMENT WILL BE FINALIZED FOR THE APRIL 2025 MAILING
-->

# Abstract                                                                      {#abstract}

This paper proposes adding support for using `std::integer_sequence` in
structured bindings and expansion statements.

# Revision history                                                              {#rev.hist}

### R1 April 2025               (mid-term mailing)                              {-}

* Updated to use the new expansion statement syntax from @P1306R3
* Added section on use in structured bindings.

### R0 June 2019                (pre-Cologne mailing)                           {-}

Original version of the paper for the 2019 pre-Cologne mailing.
 

\newpage
# Introduction                                                                  {#intro}

Expansion statements are a new language feature originally intended for C++20,
that will add compile-time iteration and code generation to C++26.

Despite feature approval by EWG for C++20, it failed to land in time due to
design and implementability concerns raised during the Core wording review.
Those concerns have now been addresses and @P1306R3 was once again approved by
EWG for adoption, now targeting C++26. 

However, there are no compile-time sequences of integers that support this
new feature, matching intuitive `for` loop indexing from the runtime world when
iteration over more than one sequence at a time is needed.  There is an easy
fix with a simple enhancement the library template `integer_sequence` to
support the structured binding API.

Additionally, since `integer_sequence` does not support the structured binding
API, there is currently no easy way to introduce a pack of integer values with
a structured binding.


# Motivation and Use Cases

Expansion statements allow for iteration over a variety of compile-time
sequences such as parameter packs and (`constexpr`) spans of reflections ---
see @P2996 for examples of reflection.  In particular, expansion statements
can iterate and generate code for any type that can, during constant evaluation,
be destructured though the structured binding API.

## Use in structured bindings

Supporting decomposition of `integer_sequence`s interacts well with the
proposed changes of @P1061R10 Structured Bindings can introduce a Pack and
@P2686R5 `constexpr` structured bindings.

In a lot of existing code the following pattern is used to introduce a sequence
of integers as a pack of constants.

```cpp
[]<std::size_t ...Idx>(std::index_sequence<Idx...>) {
  // ...
} (std::make_index_sequence<Count>());
```

Not only is this rather verbose, it introduces a new function scope. This can
be avoided by introducing the pack of integers `Idx` through a structured
binding instead.

```cpp
constexpr auto [...Idx] = std::make_index_sequence<Count>();
```

As @P1306R3 mentions, introducing a new function scope can be problematic. For
instance, reflections of function parameters (@P3096R5) can only be spliced
within their corresponding function body. Expansion statements alleviate this
issue, but are not usable whenever we want to fold over a pack of reflections
or expand them into an argument list.

For instance, consider the following (invalid) example:

```cpp
void foo(int x, char c) {
   [:expand(parameters_of(^^foo)):]
   >> []<auto... Parameters>(){
      bar([:Parameters:]...); // oops
   }
}
```

By using the features introduced in @P1061R10 and @P2686R5, the introduction of
a new function scope can be avoided.

```cpp
void foo(int x, char c) {
   constexpr auto [...Idx] = std::make_index_sequence<parameters_of(^^foo).size()>();
   bar([:parameters_of(^^foo)[Idx]:]...);
}
```

## Implementing `std::tuple::swap`

It is relatively straightforward to implement tuple::swap using a fold
expression over the comma operator, but also somewhat of a hack. This is the
kind of code we would like to be able to write more cleanly using an expansion
statement.

```cpp
template <class ...TYPES>
constexpr
void tuple<TYPES...>::swap(tuple& other)
   noexcept((is_nothrow_swappable_v<TYPES> and ...))
{
   auto impl = [&, this]<size_t...INDEX>(index_sequence<INDEX...>) {
      ((void)swap(get<INDEX>(*this), get<INDEX>(other)), ...);
   };

   impl(index_sequence_for<TYPES...>{});
}
```

Note the internal use of a lambda expression, purely to get at the parameter
pack to fold.  Also note that we must cast the call to `swap` to `void` in case
users provide an ADL-discoverable swap function that returns a user defined
type, that in turn provides an overload for the comma operator.  Finally, I
took the liberty of not replicating the exception specification on the lambda
expression, but is that relying too heavily on compilers to optimize away the
(unneeded) catch-and-abort logic?

We can eliminate the fold expression and worrying about the crazy corner cases
in ADL-swap like so:

```cpp
template <class ...TYPES>
constexpr
void tuple<TYPES...>::swap(tuple& other)
   noexcept((is_nothrow_swappable_v<TYPES> and ...))
{
   auto impl = [&, this]<size_t...INDEX>(index_sequence<INDEX...>) {
      template for(constexpr size_t N : {INDEX...}) {
        swap(get<N>(*this), get<N>(other));
      }
   };

   impl(index_sequence_for<TYPES...>{});
}
```

However, there is no easy way to eliminate the lambda expression, as we cannot
iterate over an `integer_sequence` using just the facilities provided in
@P1306R3.

The heart of the problem is that expansion statements are an excellent tool to
iterate over a single sequence, but do not provide an index to support
iterating over two sequences in parallel.  We propose that the simplest way to
resolve the concerns is to add the missing pieces that would enable use of
`integer_sequence` in a structured binding.  That is sufficient to support use
in expansion statements, and is general enough to be a feature in its own
right.  With such support, the tuple::swap example simplifies to:

```cpp
template <class ...TYPES>
constexpr
void tuple<TYPES...>::swap(tuple& other)
   noexcept((is_nothrow_swappable_v<TYPES> and ...))
{
   template for(constexpr size_t N : index_sequence_for<TYPES...>{}) {
      swap(get<N>(*this), get<N>(other));
   }
}
```

## Comparing tuples

Similarly, now that we can declare a pack of integers using the structured
binding API on an `integer_sequence`, we could implement `tuple` comparison
using a simple fold expression.

```cpp
template<class ...TTypes, class ...UTypes>
constexpr
bool operator==(tuple<TTypes...> const & lhs, tuple<UTypes...> const & rhs) {
   constexpr auto [...INDEX] = index_sequence_for<TTYPES...>{};
   return ((get<INDEX>(lhs) == get<INDEX>(rhs)) && ...);
}
```


\newpage
# Proposed Solution

## Make `integer_sequence` support structured bindings

`integer_sequence` is missing three things in order to support use in
structured bindings:

* A partial specialization for `tuple_size`
* A partial specialization for `tuple_elememt`
* Overloads of `get<INDEX>()`

The first two bullets are fairly straightforward to implement. For the `get`
function, we propose a single overload taking an `integer_sequence` by value,
as it is an immutable empty type, and likewise returning its result by value.


## Sample implementation

```cpp
template<class T, T ...VALUES>
struct tuple_size<integer_sequence<T, VALUES...>>
     : integral_constant<size_t, sizeof...(VALUES)>
{ };

template<size_t I, class T, T ...VALUES>
   requires I < sizeof...(VALUES)
struct tuple_element<I, integer_sequence<T, VALUES...>> {
  using type = T;
};

template<size_t I, class T, T ...VALUES>
   requires I < sizeof...(VALUES)
constexpr T get(integer_sequence<T, VALUES...>) noexcept {
   return VALUES...[I];
}
```


\newpage
# Wording                                                                       {#wording}

Make the following changes to the C++ Working Draft.  All wording is relative
to [@N5008], the latest draft at the time of writing.

### [utility.syn]{.sref} Header `<utility>` synopsis                            {-}

[1]{.pnum}
The header `<utility>` contains some basic function and class templates that
are used throughout the rest of the library.

```
#include <compare>          // see 17.12.1
#include <initializer_list> // see 17.11.2

namespace std {
  // 22.2.2, swap
  ...

  // 21.2, Compile-time integer sequences
  template<class T, T...>
    struct integer_sequence;
  template<size_t... I>
    using index_sequence = integer_sequence<size_t, I...>;

  template<class T, T N>
    using make_integer_sequence = integer_sequence<T, @_see below_@>;
  template<size_t N>
    using make_index_sequence = make_integer_sequence<size_t, N>;

  template<class... T>
    using index_sequence_for = make_index_sequence<sizeof...(T)>;
```

::: add
```
  // forward declaration for structured binding support
  template<class T> struct tuple_size;
  template<size_t I, class T> struct tuple_element;

  // structured binding support for integer_sequence
  template<class T, T...> struct tuple_size<integer_sequence<T, T...>>;
  template<size_t I, class T, T...> struct tuple_element<I, integer_sequence<T, T...>>;

  template<size_t I, class T, T...>
  constexpr T get(integer_sequence<T, T...>) noexcept;
```
:::

```
  // 22.3, class template pair
  template<class T1, class T2>
    struct pair;

  ...

  // 22.3.4, tuple-like access to pair
  @[template<class T> struct tuple_size;]{.rm}@
  @[template<size_t I, class T> struct tuple_element;]{.rm}@

  template<class T1, class T2> struct tuple_size<pair<T1, T2>>;
  template<size_t I, class T1, class T2> struct tuple_element<I, pair<T1, T2>>;

}
```

### [intseq]{.sref} Compile-time integer sequences                              {-}

::: add
### 21.2.4 [intseq.binding] Structured binding support                          {-}

```
template<class T, T...>
  struct tuple_size<integer_sequence<T, T...>>: integral_constant<size_t, N> { };

template<size_t I, class T, T...>
  struct tuple_element<I, integer_sequence<T, T...>>::type
```

[1]{.pnum}
_Mandates:_ `I < N` is `true`.

[2]{.pnum}
_Value:_ The type `T`.

```
template<size_t I, class T, T...>
constexpr T get(integer_sequence<T, T...>) noexcept;
```

[3]{.pnum}
_Mandates:_ `I < N` is `true`.

[4]{.pnum}
_Returns:_ The *I*<sup>th</sup> member of the parameter pack `T...`.
:::


\newpage
# Acknowledgements                                                              {#ack}

Thanks to Michael Park for the pandoc-based framework used to transform this
document's source from Markdown.

Thanks to Vittorio Romeo and Daveed Vandevoorde for their insights into the
contents of this paper.


---
references:
  - id: N5008
    citation-label: N5008
    author: Thomas KÃ¶ppe
    title:  Working Draft, Programming Languages --- C++
    URL:    https://wg21.link/n5008

  - id: P2996
    citation-label: P2996
    author: Wyatt Childers, Peter Dimov, Dan Katz, Barry Revzin, Andrew Sutton, Faisal Vali, Daveed Vandevoorde
    title: "Reflection for C++26"
    URL: https://wg21.link/p2996

---
